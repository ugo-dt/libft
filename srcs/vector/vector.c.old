#include "libft.h"

typedef void*	pointer;
typedef struct ft_allocator	ft_allocator;
typedef struct ft_vector	ft_vector;

typedef void*	pointer;
typedef void	_allocator_type;

struct _ft_allocator_type
{
	void	(*construct)(_allocator_type *self, void *value);
	void	(*destroy)(_allocator_type *self);
	size_t	size;
};

typedef void	_allocator;
typedef struct ft_allocator
{
	void*	(*allocate)(_allocator *self, size_t n);
	void	(*deallocate)(_allocator *self, void *p, size_t n);
	void	(*construct)(_allocator *self, void *p, void *val);
	void	(*destroy)(_allocator *self, void *p);
	size_t	(*max_size)(const _allocator *self);

	struct _ft_allocator_type	allocator_type;
}ft_allocator;

typedef struct ft_vector
{
	ft_allocator	alloc;
	void*			_begin;
	void*			_end;
	void*			_end_cap;
}ft_vector;

ft_allocator	ft_allocator_default(size_t type_size);

ft_vector		*ft_vector_create(size_t type_size);
ft_vector		*ft_vector_create_with_allocator(ft_allocator allocator);
ft_vector		*ft_vector_create_count(size_t type_size, size_t n, const void *x);
ft_vector		*ft_vector_create_count_with_allocator(size_t n, const void *x, ft_allocator allocator);

void			*ft_vector_begin(ft_vector *_v);
void			*ft_vector_end(ft_vector *_v);
void			*ft_vector_rbegin(ft_vector *_v);
void			*ft_vector_rend(ft_vector *_v);
void			*ft_vector_front(ft_vector *_v);
void			*ft_vector_back(ft_vector *_v);

void			_insert_in_array(ft_vector *_v, pointer p, size_t n, pointer position, const void *x);
void			_insert_in_array_range(ft_vector *_v, pointer p, pointer position, pointer first, pointer last);
void			*ft_vector_insert(ft_vector *_v, pointer position, const void *x);
void			ft_vector_insert_count(ft_vector *_v, pointer position, size_t n, const void *x);
void			ft_vector_insert_range(ft_vector *_v, pointer position, pointer first, pointer last);
void			ft_vector_erase(ft_vector *_v, pointer pos);
pointer			ft_vector_erase_range(ft_vector *_v, void *first, void *last);

void	ft_allocator_type_construct(void *_self, void *value) { (void)_self; (void)value; }
void	ft_allocator_type_destroy(void *_self) { (void)_self; }

LIBFT_BOOL	_ft_allocator_type_equals(const struct _ft_allocator_type *a, const struct _ft_allocator_type *b)
{
	return (
		a->construct == b->construct &&
		a->destroy == b->destroy &&
		a->size == b->size
	);
}

LIBFT_BOOL	ft_allocator_equals(const ft_allocator *a, const ft_allocator *b)
{
	return (
		a->allocate == b->allocate &&
		a->deallocate == b->deallocate &&
		a->construct == b->construct &&
		a->destroy == b->destroy &&
		a->max_size == b->max_size &&
		_ft_allocator_type_equals(&a->allocator_type, &b->allocator_type)
	);
}

void	*ft_allocator_allocate(void *_self, size_t n)
{
	ft_allocator *_a = (ft_allocator *)_self;

	return LIBFT_MALLOC(_a->allocator_type.size * n);
}

void	ft_allocator_deallocate(void *_self, void *p, size_t n)
{
	(void)_self; (void)n;
	free(p);
}

void	ft_allocator_construct(void *_self, void *p, void *value)
{
	ft_allocator *_a = (ft_allocator *)_self;
	_a->allocator_type.construct(p, value);
}

void	ft_allocator_destroy(void *_self, void *p)
{
	ft_allocator *_a = (ft_allocator *)_self;
	_a->allocator_type.destroy(p);
}

size_t	ft_allocator_max_size(const void *_self)
{
	(void)_self;
	return (SIZE_MAX);
}

void	ft_allocator_init(ft_allocator *_a, size_t type_size)
{
	_a->allocate = ft_allocator_allocate;
	_a->deallocate = ft_allocator_deallocate;
	_a->construct = ft_allocator_construct;
	_a->destroy = ft_allocator_destroy;
	_a->max_size = ft_allocator_max_size;
	_a->allocator_type.construct = ft_allocator_type_construct;
	_a->allocator_type.destroy = ft_allocator_type_destroy;
	_a->allocator_type.size = type_size;
}

ft_allocator	ft_allocator_default(size_t type_size)
{
	return (ft_allocator){
		.allocate = ft_allocator_allocate,
		.deallocate = ft_allocator_deallocate,
		.construct = ft_allocator_construct,
		.destroy = ft_allocator_destroy,
		.allocator_type.construct = ft_allocator_type_construct,
		.allocator_type.destroy = ft_allocator_type_destroy,
		.allocator_type.size = type_size,
	};
}

ft_allocator	*_get_allocator(ft_vector *_v)
{
	return &_v->alloc;
}

void	_copy_assign_alloc(ft_vector *_v, const ft_vector *_x)
{
	if (ft_allocator_equals(&_v->alloc, &_x->alloc) == LIBFT_FALSE)
	{
		_clear(_v);
		_v->alloc.deallocate(&_v->alloc, _v->_begin, _capacity(_v));
		_v->_begin = _v->_end = _v->_end_cap = NULL;
	}
	_v->alloc = _x->alloc;
}

ft_vector	*ft_vector_create(size_t type_size)
{
	ft_vector	*v;

	LIBFT_ASSERT(type_size < SIZE_MAX);
	v = LIBFT_MALLOC(sizeof(ft_vector));
	LIBFT_ASSERT(v);

	ft_allocator_init(&v->alloc, type_size);
	v->_begin = v->_end = v->_end_cap = NULL;
	return v;
}

ft_vector	*ft_vector_create_with_allocator(ft_allocator allocator)
{
	ft_vector	*v;

	v = LIBFT_MALLOC(sizeof(ft_vector));
	LIBFT_ASSERT(v);

	v->alloc = allocator;
	v->_begin = v->_end = v->_end_cap = NULL;
	return v;
}

ft_vector	*ft_vector_create_count(size_t type_size, size_t n, const void *x)
{
	ft_vector	*v;

	LIBFT_ASSERT(type_size < SIZE_MAX);
	v = LIBFT_MALLOC(sizeof(ft_vector));
	LIBFT_ASSERT(v);

	ft_allocator_init(&v->alloc, type_size);
	if (n < 0)
		v->_begin = v->_end = v->_end_cap = NULL;
	else
	{
		_vallocate(v, n);
		_construct_at_end(v, n, x);
	}
	return v;
}

ft_vector	*ft_vector_create_count_with_allocator(size_t n, const void *x, ft_allocator allocator)
{
	ft_vector	*v;

	v = LIBFT_MALLOC(sizeof(ft_vector));
	LIBFT_ASSERT(v);

	v->alloc = allocator;
	if (n < 0)
		v->_begin = v->_end = v->_end_cap = NULL;
	else
	{
		_vallocate(v, n);
		_construct_at_end(v, n, x);
	}
	return v;
}

void	*ft_vector_begin(ft_vector *_v)
{
	return _v->_begin;
}

void	*ft_vector_end(ft_vector *_v)
{
	return _v->_end;
}

void	*ft_vector_rbegin(ft_vector *_v)
{
	return (void *)((size_t)_v->_end - _v->alloc.allocator_type.size);
}

void	*ft_vector_rend(ft_vector *_v)
{
	return _v->_begin;
}

ft_allocator	*ft_vector_get_allocator(ft_vector *_v)
{
	return &_v->alloc;
}

void	*ft_vector_front(ft_vector *_v)
{
	return _v->_begin;
}

void	*ft_vector_back(ft_vector *_v)
{
	return (void *)((size_t)_v->_end - _v->alloc.allocator_type.size);
}

void	ft_vector_assign_range(ft_vector *_v, pointer first, pointer last)
{
	_clear(_v);
	while (first != last)
	{
		ft_vector_push_back(_v, first);
		first = (void *)((size_t)first + _v->alloc.allocator_type.size);
	}
}

void	_insert_in_array(ft_vector *_v, pointer p, size_t n, pointer position, const void *x)
{
	size_t	typesize = _v->alloc.allocator_type.size;
	int i = 0;
	pointer it;

	it = _v->_begin;
	while (it != position)
	{
		ft_memcpy((void *)((size_t)p + (i * typesize)), it, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
		it = (void *)((size_t)it + typesize);
	}
	while (n--)
	{
		ft_memcpy((void *)((size_t)p + (i * typesize)), x, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
	}
	while (it != _v->_end)
	{
		ft_memcpy(p, it, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
		it = (void *)((size_t)it + typesize);
	}
}

void	_insert_in_array_range(ft_vector *_v, pointer p, pointer position, pointer first, pointer last)
{
	size_t	typesize = _v->alloc.allocator_type.size;
	int i = 0;
	pointer it;

	it = _v->_begin;
	while (it != position)
	{
		ft_memcpy((void *)((size_t)p + (i * typesize)), it, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
		it = (void *)((size_t)it + typesize);
	}
	while (first != last)
	{
		ft_memcpy(p, first, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
		first = (void *)((size_t)first + typesize);
	}
	while (it != _v->_end)
	{
		ft_memcpy(p, it, typesize);
		i++;
		p = (void *)((size_t)p + typesize);
		it = (void *)((size_t)it + typesize);
	}
}

void	*ft_vector_insert(ft_vector *_v, pointer position, const void *x)
{
	ptrdiff_t d = (size_t)position - (size_t)_v->_begin;
	pointer p = (void *)((size_t)_v->_begin + d);
	if (_v->_end < _v->_end_cap)
	{
		if (p == _v->_end)
		{
			ft_vector_push_back(_v, x);
		}
		else
		{
			_insert_in_array(_v, _v->_begin, 1, position, x);
			_v->_end = (void *)((size_t)_v->_end + _v->alloc.allocator_type.size);
		}
	}
	else
	{
		ft_vector   *new_v = ft_vector_create_count_with_allocator(ft_vector_size(_v) + 1, x, _v->alloc);
		_insert_in_array(new_v, new_v->_begin, 1, position, x);
		swap(_v, new_v);
		ft_vector_destroy(new_v);
	}
	return ((void *)((size_t)_v->_begin + d));
}

void	ft_vector_insert_count(ft_vector *_v, pointer position, size_t n, const void *x)
{
	if (n < 0)
		return ;
	if (n <= (size_t)_v->_end_cap - (size_t)_v->_end)
	{
		_insert_in_array(_v, _v->_begin, n, position, x);
		_v->_end = (void *)((size_t)_v->_end + n * _v->alloc.allocator_type.size);
	}
	else
	{
		ft_vector   *new_v = ft_vector_create_count_with_allocator(ft_vector_size(_v) + n, x, _v->alloc);
		_insert_in_array(new_v, new_v->_begin, n, position, x);
		swap(_v, new_v);
		ft_vector_destroy(new_v);
	}
}

void	ft_vector_insert_range(ft_vector *_v, pointer position, pointer first, pointer last)
{
	size_t n = 0;
	pointer tmp = first;
	while (tmp != last)
	{
		n++;
		tmp = (void *)((size_t)tmp + _v->alloc.allocator_type.size);
	}
	if (n < 0)
		return ;
	if (n <= (size_t)_v->_end_cap - (size_t)_v->_end)
	{
		_insert_in_array_range(_v, _v->_begin, position, first, last);
		_v->_end = (void *)((size_t)_v->_end + n * _v->alloc.allocator_type.size);
	}
	else
	{
		ft_vector	*new_v = ft_vector_create_count_with_allocator(ft_vector_size(_v) + n, first, _v->alloc);
		_insert_in_array_range(new_v, new_v->_begin, position, first, last);
		swap(_v, new_v);
		ft_vector_destroy(new_v);
	}
}

void	ft_vector_erase(ft_vector *_v, pointer pos)
{
	ft_vector_erase_range(_v, pos, (void *)((size_t)pos + _v->alloc.allocator_type.size));
}

pointer	ft_vector_erase_range(ft_vector *_v, void *first, void *last)
{
	size_t	typesize = _v->alloc.allocator_type.size;
	pointer r = first;
	size_t n = 0;
	pointer tmp = first;
	while (tmp != last)
	{
		n++;
		tmp = (void *)((size_t)tmp + typesize);
	}
	while (last != _v->_end)
	{
		ft_memcpy(first, last, typesize);
		first = (void *)((size_t)first + typesize);
		last = (void *)((size_t)last + typesize);
	}
	while (n--)
		_destruct_at_end(_v, ft_vector_rbegin(_v));
	return (r);
}

void	_swap(pointer *a, pointer *b)
{
	pointer c = *a;

	*a = *b;
	*b = c;
}

void	swap(ft_vector *_v, ft_vector *_x)
{
	_swap(&_v->_begin, &_x->_begin);
	_swap(&_v->_end, &_x->_end);
	_swap(&_v->_end_cap, &_x->_end_cap);

	ft_allocator	a = _v->alloc;
	_v->alloc = _x->alloc;
	_x->alloc = a;
}
